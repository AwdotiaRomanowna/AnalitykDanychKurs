I"wD<p>As the popularity of the application grows, the application needs to scale appropriately as demand changes.
Ensure the application remains responsive as the number of order submissions increases.</p>

<h3 id="tasks">Tasks</h3>

<h4 id="run-a-baseline-load-test">Run a baseline load test</h4>

<p><strong>Task Hints</strong></p>
<ul>
  <li>A pre-built image on Dockerhub has been created called <code class="language-plaintext highlighter-rouge">azch/loadtest</code>, this uses a tool called ‘hey’ to inject a large amount of traffic to the capture order API</li>
  <li><a href="https://docs.microsoft.com/en-gb/azure/container-instances/">Azure Container Instances</a> can be used to run this image as a container, e.g using the  <code class="language-plaintext highlighter-rouge">az container create</code> command.</li>
  <li>When running as a Container Instance set we don’t want it to restart once it has finished, so set <code class="language-plaintext highlighter-rouge">--restart-policy Never</code></li>
  <li>Provide the endpoint of your capture orders service in <code class="language-plaintext highlighter-rouge">SERVICE_ENDPOINT</code> environmental variable e.g. <code class="language-plaintext highlighter-rouge">-e SERVICE_ENDPOINT=https://orders.{ingress-ip}.nip.io</code></li>
  <li>You can watch the orders come in using the Frontend application, and can view the detailed output of the load test with the <code class="language-plaintext highlighter-rouge">az container logs</code> command</li>
  <li>Make a note of the results, response times etc</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>There is a container image on Docker Hub (<a href="https://hub.docker.com/r/azch/loadtest">azch/loadtest</a>) that is preconfigured to run the load test. You may run it in <a href="https://azure.microsoft.com/en-us/services/container-instances/">Azure Container Instances</a> running the command below</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az container create <span class="nt">-g</span> &lt;resource-group&gt; <span class="nt">-n</span> loadtest <span class="nt">--image</span> azch/loadtest <span class="nt">--restart-policy</span> Never <span class="nt">-e</span> <span class="nv">SERVICE_ENDPOINT</span><span class="o">=</span>https://&lt;<span class="nb">hostname </span>order capture service&gt;
</code></pre></div></div>

<p>This will fire off a series of increasing loads of concurrent users (100, 400, 1600, 3200, 6400) POSTing requests to your Order Capture API endpoint with some wait time in between to simulate an increased pressure on your application.</p>

<p>You may view the logs of the Azure Container Instance by running the command below.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az container logs <span class="nt">-g</span> &lt;resource-group&gt; <span class="nt">-n</span> loadtest <span class="nt">--follow</span>
</code></pre></div></div>

<p>When you’re done, you may delete it by running</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az container delete <span class="nt">-g</span> &lt;resource-group&gt; <span class="nt">-n</span> loadtest
</code></pre></div></div>

<p>Make note of results (sample below), figure out what is the breaking point for the number of users.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Phase 5: Load test - 30 seconds, 6400 users.

Summary:
  Total:	41.1741 secs
  Slowest:	23.7166 secs
  Fastest:	0.8882 secs
  Average:	9.7952 secs
  Requests/sec:	569.1929

  Total data:	1003620 bytes
  Size/request:	43 bytes

Response time histogram:
  0.888 [1]	|
  3.171 [1669]	|■■■■■■■■■■■■■■
  5.454 [1967]	|■■■■■■■■■■■■■■■■■
  7.737 [4741]	|■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  10.020 [3660]	|■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  12.302 [3786]	|■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  14.585 [4189]	|■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  16.868 [2583]	|■■■■■■■■■■■■■■■■■■■■■■
  19.151 [586]	|■■■■■
  21.434 [151]	|■
  23.717 [7]	|

Status code distribution:
  [200]	23340 responses

Error distribution:
  [96]	Post http://23.96.91.35/v1/order: net/http: request canceled (Client.Timeout exceeded while awaiting headers)
</code></pre></div></div>

<p>You may use the Azure Monitor (previous task) to view the logs and figure out where you need to optimize to increase the throughtput (requests/sec), reduce the average latency and error count.</p>

<p><img src="media/captureorder-loadtest-log.png" alt="Azure Monitor container insights" /></p>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="create-horizontal-pod-autoscaler">Create Horizontal Pod Autoscaler</h4>

<p>Most likely in your initial test, the <code class="language-plaintext highlighter-rouge">captureorder</code> container was the bottleneck. So the first step would be to scale it out. There are two ways to do so</p>

<ul>
  <li>You can manually increase the number of replicas in the deployment by using the <code class="language-plaintext highlighter-rouge">kubectl scale</code> command or by editing the deployment’s YAML file</li>
  <li>You can use the Horizontal Pod Autoscaler (HPA) to automatically adjust the number of replicas based on demand</li>
</ul>

<p>Horizontal Pod Autoscaler allows Kubernetes to detect when your deployed pods need more resources and then it schedules more pods onto the cluster to cope with the demand.</p>

<p><strong>Task Hints</strong></p>
<ul>
  <li>The <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale">Horizontal Pod Autoscaler</a> (HPA) is a way for deployments to scale their pods out automatically based on metrics such as CPU utilization.</li>
  <li>There are two versions of the HPA object - <code class="language-plaintext highlighter-rouge">autoscaling/v1</code> and <code class="language-plaintext highlighter-rouge">autoscaling/v2beta2</code>. The <code class="language-plaintext highlighter-rouge">v2beta2</code> adds support for multiple metrics, custom metrics and other features. For this workshop though, the capabilities of the <code class="language-plaintext highlighter-rouge">v1</code> version are sufficient.</li>
  <li>The <code class="language-plaintext highlighter-rouge">kubectl autoscale</code> command can easily set up a HPA for any deployment, <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#create-horizontal-pod-autoscaler">this walkthrough guide has an example you can re-use.</a></li>
  <li>Alternatively you can define the HPA object in a YAML file.</li>
  <li>For the HPA to work, you must add <a href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/">resource limits</a> to your captureorder deployment, if you haven’t already done so. Good values to use are <code class="language-plaintext highlighter-rouge">cpu: "500m"</code> (which is equivalent to half a CPU core), and for memory specify <code class="language-plaintext highlighter-rouge">memory: "256Mi"</code>.</li>
  <li>Validate the HPA with <code class="language-plaintext highlighter-rouge">kubectl get hpa</code> and make sure the <code class="language-plaintext highlighter-rouge">Targets</code> column is not showing <code class="language-plaintext highlighter-rouge">&lt;unknown&gt;</code></li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>Save the YAML below as <code class="language-plaintext highlighter-rouge">captureorder-hpa.yaml</code> or download it from <a href="yaml-solutions/01. challenge-04/captureorder-hpa.yaml">captureorder-hpa.yaml</a></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">autoscaling/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">HorizontalPodAutoscaler</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">captureorder</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">scaleTargetRef</span><span class="pi">:</span>
    <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">captureorder</span>
  <span class="na">minReplicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">maxReplicas</span><span class="pi">:</span> <span class="m">10</span>
  <span class="na">targetCPUUtilizationPercentage</span><span class="pi">:</span> <span class="m">50</span>
</code></pre></div></div>

<p>And deploy it using</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> captureorder-hpa.yaml
</code></pre></div></div>

<blockquote>
  <p><strong>Important</strong> For the Horizontal Pod Autoscaler to work, you <strong>MUST</strong> define requests and limits in the Capture Order API’s deployment.</p>
</blockquote>

    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="run-a-load-test-again-after-applying-horizontal-pod-autoscaler">Run a load test again after applying Horizontal Pod Autoscaler</h4>

<p><strong>Task Hints</strong></p>
<ul>
  <li>Delete your load test container instance (<code class="language-plaintext highlighter-rouge">az container delete</code>) and re-create it to run another test, with the same parameters as before</li>
  <li>Watch the behavior of the HPA with <code class="language-plaintext highlighter-rouge">kubectl get hpa</code> and use <code class="language-plaintext highlighter-rouge">kubectl get pod</code> to see the new captureorder pods start, when auto-scaling triggers more replicas</li>
  <li>Observe the change in load test results</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>If you didn’t delete the load testing Azure Container Instance, delete it now</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az container delete <span class="nt">-g</span> &lt;resource-group&gt; <span class="nt">-n</span> loadtest
</code></pre></div></div>

<p>Running the load test again</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az container create <span class="nt">-g</span> &lt;resource-group&gt; <span class="nt">-n</span> loadtest <span class="nt">--image</span> azch/loadtest <span class="nt">--restart-policy</span> Never <span class="nt">-e</span> <span class="nv">SERVICE_ENDPOINT</span><span class="o">=</span>https://&lt;<span class="nb">hostname </span>order capture service&gt;
</code></pre></div></div>

<p>Observe your Kubernetes cluster reacting to the load by running</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">-l</span>  <span class="nv">app</span><span class="o">=</span>captureorder
</code></pre></div></div>

<video width="100%" controls="">
  <source src="media/autoscale-in-action.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="check-if-your-cluster-nodes-needs-to-scaleautoscale">Check if your cluster nodes needs to scale/autoscale</h4>

<p><strong>Task Hints</strong></p>
<ul>
  <li>As the HPA scales out with more &amp; more pods, eventually the cluster will run out of resources. You will see pods in pending state.</li>
  <li>You can use the <code class="language-plaintext highlighter-rouge">kubectl describe hpa &lt;hpa-name&gt;</code> command to see more information about what the HPA is doing and when it triggers the deployment of additional pods or removal of surplus pods</li>
  <li>You can use the <code class="language-plaintext highlighter-rouge">kubectl top</code> command to view the CPU and memory utilisation of <code class="language-plaintext highlighter-rouge">pods</code> and <code class="language-plaintext highlighter-rouge">nodes</code>. This will tell you whether the cluster is hitting CPU and memory limits and should therefore need to scale.</li>
  <li>You may have to artificially force this situation by increasing the resource <code class="language-plaintext highlighter-rouge">request</code> and <code class="language-plaintext highlighter-rouge">limit</code> for memory in the captureorder deployment to <code class="language-plaintext highlighter-rouge">memory: "4G"</code> or even <code class="language-plaintext highlighter-rouge">memory: "2G"</code> (and re-deploy/apply the deployment)</li>
  <li>If you enabled the cluster autoscaler, you might be able to get the cluster to scale automatically, check the node count with <code class="language-plaintext highlighter-rouge">kubectl get nodes</code>.</li>
  <li>If you didn’t enable the autoscaler you can try manually scaling with the <code class="language-plaintext highlighter-rouge">az aks scale</code> command and the <code class="language-plaintext highlighter-rouge">--node-count</code> parameter</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>If your AKS cluster is not configured with the cluster autoscaler, scale the cluster nodes using the command below to the required number of nodes</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az aks scale <span class="nt">--resource-group</span> &lt;resource-group&gt; <span class="nt">--name</span> &lt;unique-aks-cluster-name&gt; <span class="nt">--node-count</span> 4
</code></pre></div></div>

<p>Otherwise, if you configured your AKS cluster with cluster autoscaler, you should see it dynamically adding and removing nodes based on the cluster utilization. To change the node count, use the <code class="language-plaintext highlighter-rouge">az aks update</code> command and specify a minimum and maximum value. The following example sets the <code class="language-plaintext highlighter-rouge">--min-count</code> to <em>1</em> and the <code class="language-plaintext highlighter-rouge">--max-count</code> to <em>5</em>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az aks update <span class="se">\</span>
  <span class="nt">--resource-group</span> &lt;resource-group&gt; <span class="se">\</span>
  <span class="nt">--name</span> &lt;unique-aks-cluster-name&gt; <span class="se">\</span>
  <span class="nt">--update-cluster-autoscaler</span> <span class="se">\</span>
  <span class="nt">--min-count</span> 1 <span class="se">\</span>
  <span class="nt">--max-count</span> 5
</code></pre></div></div>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<blockquote>
  <p><strong>Resources</strong></p>
  <ul>
    <li><a href="https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-scale">https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-scale</a></li>
    <li><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale</a></li>
    <li><a href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container">https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container</a></li>
    <li><a href="https://docs.microsoft.com/en-us/azure/aks/autoscaler">https://docs.microsoft.com/en-us/azure/aks/autoscaler</a></li>
  </ul>
</blockquote>
:ET