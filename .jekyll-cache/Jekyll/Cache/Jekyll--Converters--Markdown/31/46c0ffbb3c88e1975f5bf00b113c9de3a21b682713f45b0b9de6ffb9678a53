I")Y<p>You want to enable secure connections to the Frontend website over TLS (SSL). In this task, you’ll use <a href="https://letsencrypt.org/">Let’s Encrypt</a>’s free service to generate valid TLS certificates for your domains, and you’ll integrate the certificate issuance workflow into Kubernetes.</p>

<h3 id="tasks">Tasks</h3>

<h4 id="install-cert-manager">Install <code class="language-plaintext highlighter-rouge">cert-manager</code></h4>

<p><a href="https://github.com/jetstack/cert-manager">cert-manager</a> is a Kubernetes add-on to automate the management and issuance of TLS certificates from various issuing sources. It will ensure certificates are valid and up to date periodically, and attempt to renew certificates at an appropriate time before expiry.</p>

<p><strong>Task Hints</strong></p>
<ul>
  <li>As with MongoDB and NGINX use Helm to deploy cert-manager. You need to do a little more than just <code class="language-plaintext highlighter-rouge">helm install</code>, however the <a href="https://github.com/helm/charts/tree/master/stable/cert-manager#installing-the-chart">steps are documented in the GitHub repo for the cert-manager chart</a></li>
  <li>It’s recommended to install the chart into a different/name namespace</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>Install <strong>cert-manager</strong> using Helm and configure it to use <code class="language-plaintext highlighter-rouge">letsencrypt</code> as the certificate issuer.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Install the CustomResourceDefinition resources separately</span>
kubectl apply <span class="nt">--validate</span><span class="o">=</span><span class="nb">false</span> <span class="nt">-f</span> https://raw.githubusercontent.com/jetstack/cert-manager/release-0.11/deploy/manifests/00-crds.yaml

<span class="c"># Create the namespace for cert-manager</span>
kubectl create namespace cert-manager

<span class="c"># Add the Jetstack Helm repository</span>
helm repo add jetstack https://charts.jetstack.io

<span class="c"># Update your local Helm chart repository cache</span>
helm repo update

<span class="c"># Install the cert-manager Helm chart</span>
helm <span class="nb">install </span>cert-manager <span class="se">\</span>
  <span class="nt">--namespace</span> cert-manager <span class="se">\</span>
  jetstack/cert-manager
</code></pre></div></div>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="create-a-lets-encrypt-clusterissuer">Create a Let’s Encrypt ClusterIssuer</h4>

<p>In order to begin issuing certificates, you will need to set up a <code class="language-plaintext highlighter-rouge">ClusterIssuer</code>.</p>

<p><strong>Task Hints</strong></p>
<ul>
  <li>cert-manager uses a custom Kubernetes object called an <strong>Issuer</strong> or <strong>ClusterIssuer</strong> to act as the interface between you and the certificate issuing service (in our case Let’s Encrypt). There are many ways to create an issuer, but <a href="https://cert-manager.readthedocs.io/en/latest/reference/issuers.html#issuers">the cert-manager docs provides a working example YAML for Let’s Encrypt</a>. It will require some small modifications, <strong>You must change the type to <code class="language-plaintext highlighter-rouge">ClusterIssuer</code> or it will not work</strong>. The recommendation is you call the issuer <code class="language-plaintext highlighter-rouge">letsencrypt</code></li>
  <li>Check the status with <code class="language-plaintext highlighter-rouge">kubectl describe clusterissuer.cert-manager.io/letsencrypt</code> (or other name if you didn’t call your issuer <code class="language-plaintext highlighter-rouge">letsencrypt</code>)</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>Save the YAML below as <code class="language-plaintext highlighter-rouge">letsencrypt-clusterissuer.yaml</code> or download it from <a href="yaml-solutions/advanced/letsencrypt-clusterissuer.yaml">letsencrypt-clusterissuer.yaml</a>.</p>

<blockquote>
  <p><strong>Note</strong> Make sure to replace <code class="language-plaintext highlighter-rouge">_YOUR_EMAIL_</code> with your email.</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">cert-manager.io/v1alpha2</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterIssuer</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">letsencrypt</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">acme</span><span class="pi">:</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">https://acme-v02.api.letsencrypt.org/directory</span> <span class="c1"># production</span>
    <span class="c1">#server: https://acme-staging-v02.api.letsencrypt.org/directory # staging</span>
    <span class="na">email</span><span class="pi">:</span> <span class="s">_YOUR_EMAIL_</span> <span class="c1"># replace this with your email</span>
    <span class="na">privateKeySecretRef</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">letsencrypt</span>
    <span class="na">solvers</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">http01</span><span class="pi">:</span>
           <span class="na">ingress</span><span class="pi">:</span>
             <span class="na">class</span><span class="pi">:</span>  <span class="s">nginx</span>
</code></pre></div></div>

<p>And apply it using</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> letsencrypt-clusterissuer.yaml
</code></pre></div></div>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="update-the-ingress-resource-to-automatically-request-a-certificate">Update the ingress resource to automatically request a certificate</h4>

<p>Issuing certificates can be done automatically by properly annotating the ingress resource.</p>

<p><strong>Task Hints</strong></p>
<ul>
  <li>You need to make changes to the frontend ingress, you can modify your existing frontend ingress YAML file or make a copy to a new name</li>
  <li><a href="https://cert-manager.readthedocs.io/en/latest/tutorials/acme/quick-start/index.html#step-7-deploy-a-tls-ingress-resource">The quick start guide for cert-manager provides guidance on the changes you need to make</a>. Note the following:
    <ul>
      <li>The annotation <code class="language-plaintext highlighter-rouge">cert-manager.io/issuer: "letsencrypt-staging"</code> in the metadata, you want that to refer to your issuer <code class="language-plaintext highlighter-rouge">letsencrypt</code> and use cluster-issuer rather than issuer, e.g. <code class="language-plaintext highlighter-rouge">cert-manager.io/cluster-issuer: "letsencrypt"</code></li>
      <li>The new <code class="language-plaintext highlighter-rouge">tls:</code> section, here the <code class="language-plaintext highlighter-rouge">host</code> field should match the host in your rules section, and the <code class="language-plaintext highlighter-rouge">secretName</code> can be anything you like, this will be the name of the certificate issued (see next step)</li>
    </ul>
  </li>
  <li>Reapply your changed frontend ingress using <code class="language-plaintext highlighter-rouge">kubectl</code></li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>Save the YAML below as <code class="language-plaintext highlighter-rouge">frontend-ingress-tls.yaml</code> or download it from <a href="yaml-solutions/advanced/frontend-ingress-tls.yaml">frontend-ingress-tls.yaml</a>.</p>

<blockquote>
  <p><strong>Note</strong> Make sure to replace <code class="language-plaintext highlighter-rouge">_INGRESS_CONTROLLER_EXTERNAL_IP_</code> with your cluster ingress controller external IP. Also make note of the <code class="language-plaintext highlighter-rouge">secretName: frontend-tls-secret</code> as this is where the issued certificate will be stored as a Kubernetes secret.</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">frontend</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="s">kubernetes.io/ingress.class</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="s">cert-manager.io/cluster-issuer</span><span class="pi">:</span> <span class="s">letsencrypt</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">tls</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">frontend._INGRESS_CONTROLLER_EXTERNAL_IP_.nip.io</span>
    <span class="na">secretName</span><span class="pi">:</span> <span class="s">frontend-tls-secret</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">frontend._INGRESS_CONTROLLER_EXTERNAL_IP_.nip.io</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">backend</span><span class="pi">:</span>
          <span class="na">serviceName</span><span class="pi">:</span> <span class="s">frontend</span>
          <span class="na">servicePort</span><span class="pi">:</span> <span class="m">80</span>
        <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
</code></pre></div></div>

<p>And apply it using</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> frontend-ingress-tls.yaml
</code></pre></div></div>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="verify-the-certificate-is-issued-and-test-the-website-over-ssl">Verify the certificate is issued and test the website over SSL</h4>

<p><strong>Task Hints</strong></p>
<ul>
  <li>You can list custom objects such as certificates with regular <code class="language-plaintext highlighter-rouge">kubectl</code> commands, e.g. <code class="language-plaintext highlighter-rouge">kubectl get cert</code> and <code class="language-plaintext highlighter-rouge">kubectl describe cert</code>, use the describe command to validate the cert has been issued and is valid</li>
  <li>Access the front end in your browser as before, e.g. <code class="language-plaintext highlighter-rouge">http://frontend.{ingress-ip}.nip.io</code> you might be automatically redirected to the <code class="language-plaintext highlighter-rouge">https://</code> version, if not modify the URL to access using <code class="language-plaintext highlighter-rouge">https://</code></li>
  <li><strong>You will probably see nothing in the Orders view, and some errors in the developer console (F12)</strong>, to fix this you will need to do some work to make the Order Capture API accessible over HTTPS with TLS. See the next section for more details.</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<p>Let’s Encrypt should automatically verify the hostname in a few seconds. Make sure that the certificate has been issued by running:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe certificate frontend
</code></pre></div></div>

<p>You should get back something like:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Name:         frontend-tls-secret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  cert-manager.io/v1alpha2
Kind:         Certificate
Metadata:
  Creation Timestamp:  2020-01-30T14:14:53Z
  Generation:          2
  Owner References:
    API Version:           extensions/v1beta1
    Block Owner Deletion:  <span class="nb">true
    </span>Controller:            <span class="nb">true
    </span>Kind:                  Ingress
    Name:                  frontend
    UID:                   069293aa-68a8-4d63-8093-9b82f018f985
  Resource Version:        326924
  Self Link:               /apis/cert-manager.io/v1alpha2/namespaces/default/certificates/frontend-tls-secret
  UID:                     acf4834f-5ad7-42da-b660-be0dfed7eae0
Spec:
  Dns Names:
    frontend.51.105.126.236.nip.io
  Issuer Ref:
    Group:      cert-manager.io
    Kind:       ClusterIssuer
    Name:       letsencrypt
  Secret Name:  frontend-tls-secret
Status:
  Conditions:
    Last Transition Time:  2020-01-30T14:19:32Z
    Message:               Certificate is up to <span class="nb">date </span>and has not expired
    Reason:                Ready
    Status:                True
    Type:                  Ready
  Not After:               2020-04-29T13:19:31Z
Events:
  Type    Reason        Age    From          Message
  <span class="nt">----</span>    <span class="nt">------</span>        <span class="nt">----</span>   <span class="nt">----</span>          <span class="nt">-------</span>
  Normal  GeneratedKey  6m23s  cert-manager  Generated a new private key
  Normal  Requested     6m23s  cert-manager  Created new CertificateRequest resource <span class="s2">"frontend-tls-secret-21669938"</span>
  Normal  Requested     2m11s  cert-manager  Created new CertificateRequest resource <span class="s2">"frontend-tls-secret-253990887"</span>
  Normal  Issued        104s   cert-manager  Certificate issued successfully

</code></pre></div></div>

<p>Verify that the frontend is accessible over HTTPS and that the certificate is valid.</p>

<p><img src="media/ssl-certificate.png" alt="Let's Encrypt SSL certificate" /></p>

<p>Note: even if the certificate is valid, you may still get a warning in your browser because of the unsafe cross-site scripting.</p>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<h4 id="enable-tls-for-the-order-capture-api-to-fix-the-frontend-application">Enable TLS for the Order Capture API to fix the Frontend application</h4>

<p>You should have noticed that the Frontend application now appears to be broken as it displays the <strong>Orders</strong> title but no order details beneath. This is because the Order Capture API is still using an unsecured HTTP connection and your web browser is blocking this unsafe content. To fix this, we need to enable TLS for the Order Capture API as well.</p>

<p><strong>Task Hints</strong></p>
<ul>
  <li>This is pretty much a repeat of the work you did when creating the Frontend ingress resource, so you just need to make a copy of the ingress YAML and configure it to direct traffic to the ‘captureorder’ service.</li>
  <li>You will need a new hostname, but it can still use the same Ingress Controller - for example <code class="language-plaintext highlighter-rouge">ordercapture.{ingress-ip}.nip.io</code>.</li>
  <li>The web root of the Capture Order API returns a 404. During setup of the cert, LetsEncrypt may send a challenge to the address you specify for the Caputure Order API to ensure it’s valid, but it will be expecting a 200 response. Therefore, you may need to configre the Ingress to redirect traffic from root <code class="language-plaintext highlighter-rouge">/</code> to a location that returns a response, such as <code class="language-plaintext highlighter-rouge">/v1/order</code></li>
  <li>Modify the <code class="language-plaintext highlighter-rouge">CAPTUREORDERSERVICEIP</code> environment variable in the Frontend deployment YAML. This now needs to refer to the hostname of your new <code class="language-plaintext highlighter-rouge">ordercapture</code> ingress instead of the IP address of the <code class="language-plaintext highlighter-rouge">ordercapture</code> service. You will need to redeploy the frontend to make the changes live.</li>
</ul>

<!-- Begin collapsible container div -->
<div class="collapsible-content-container">
  <!-- Begin collapsible container button -->
  <button class="toggle-collapsible">Toggle solution</button>
  <!-- Begin collapsible container content div -->
  <div class="collapsible-content">
    <!-- Begin parsedText -->
    
<h4 id="create-a-new-kubernetes-ingress-resource-to-direct-traffic-to-the-captureorder-service">Create a new Kubernetes Ingress resource to direct traffic to the <code class="language-plaintext highlighter-rouge">captureorder</code> service</h4>

<p>Save the YAML below as <code class="language-plaintext highlighter-rouge">captureorder-ingress-tls.yaml</code> or download it from <a href="yaml-solutions/advanced/captureorder-ingress-tls.yaml">captureorder-ingress-tls.yaml</a>.</p>

<blockquote>
  <p><strong>Note</strong> Make sure to replace <code class="language-plaintext highlighter-rouge">_INGRESS_CONTROLLER_EXTERNAL_IP_</code> with your cluster’s ingress controller external IP.</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: captureorder
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt
    nginx.ingress.kubernetes.io/app-root: /v1/order
spec:
  tls:
  - hosts:
    - captureorder._INGRESS_CONTROLLER_EXTERNAL_IP_.nip.io
    secretName: captureorder-tls-secret
  rules:
  - host: captureorder._INGRESS_CONTROLLER_EXTERNAL_IP_.nip.io
    http:
      paths:
      - backend:
          serviceName: captureorder
          servicePort: 80
        path: /
</code></pre></div></div>

<p>You should now be able to query the <code class="language-plaintext highlighter-rouge">/v1/orders</code> endpoint or open the <code class="language-plaintext highlighter-rouge">/swagger</code> endpoint using HTTPS.</p>

<h4 id="update-the-frontend-deployment-to-use-https-to-access-the-capture-order-api">Update the Frontend deployment to use HTTPS to access the Capture Order API</h4>

<p>We need to redeploy the Frontend application so that it accesses the Capture Order API via the newly created Ingress</p>

<p>Save the YAML below as <code class="language-plaintext highlighter-rouge">frontend-deployment.yaml</code> or download it from <a href="yaml-solutions/advanced/frontend-deployment.yaml">frontend-deployment.yaml</a>.</p>

<blockquote>
  <p><strong>Note</strong> Make sure to replace <code class="language-plaintext highlighter-rouge">_INGRESS_CONTROLLER_EXTERNAL_IP_</code> with your cluster’s ingress controller external IP.</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  selector:
      matchLabels:
        app: frontend
  replicas: 1
  template:
      metadata:
        labels:
            app: frontend
      spec:
        containers:
        - name: frontend
          image: azch/frontend
          imagePullPolicy: Always
          readinessProbe:
            httpGet:
              port: 8080
              path: /
          livenessProbe:
            httpGet:
              port: 8080
              path: /
          resources:
            requests:
              memory: <span class="s2">"128Mi"</span>
              cpu: <span class="s2">"100m"</span>
            limits:
              memory: <span class="s2">"256Mi"</span>
              cpu: <span class="s2">"500m"</span>
          <span class="nb">env</span>:
          - name: CAPTUREORDERSERVICEIP
            value: <span class="s2">"captureorder._INGRESS_CONTROLLER_EXTERNAL_IP_.nip.io"</span>
          ports:
          - containerPort: 8080
</code></pre></div></div>

<p>You should now be able to open the Frontend application and the order information should be displayed correctly.</p>


    <!-- End parsedText -->
  </div>
  <!-- End collapsible container content div -->
</div>
<!-- End collapsible container div -->

<blockquote>
  <p><strong>Resources</strong></p>
  <ul>
    <li><a href="https://github.com/helm/charts/tree/master/stable/cert-manager">https://github.com/helm/charts/tree/master/stable/cert-manager</a></li>
    <li><a href="https://cert-manager.readthedocs.io/en/latest/reference/issuers.html">https://cert-manager.readthedocs.io/en/latest/reference/issuers.html</a></li>
    <li><a href="https://cert-manager.readthedocs.io/en/latest/tutorials/acme/quick-start">https://cert-manager.readthedocs.io/en/latest/tutorials/acme/quick-start</a></li>
  </ul>
</blockquote>

<h3 id="architecture-diagram">Architecture Diagram</h3>
<p>Here’s a high level diagram of the components you will have deployed when you’ve finished this section (click the picture to enlarge)</p>

<p><a href="media/architecture/tls-certs.png" target="_blank"><img src="media/architecture/tls-certs.png" style="width:500px" /></a></p>
:ET